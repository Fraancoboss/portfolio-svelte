import{f as s,a as c}from"../chunks/BMF6T9tb.js";import"../chunks/tebz14wc.js";import{n as p}from"../chunks/DE_jnxu_.js";import{l as n,s as l}from"../chunks/ClIJsDuP.js";import{P as d}from"../chunks/BaXfQtvu.js";const e={title:"Firmas post-cuánticas ligeras con Rust",excerpt:"Experimentos con libsodium, PQClean y runtimes embebidos para asegurar comunicaciones en clientes offline.",category:"Criptografía",publishedAt:"2024-07-18",readingTime:"6 min",tags:["PQC","Rust","TLS"]},{title:y,excerpt:_,category:v,publishedAt:x,readingTime:P,tags:A}=e;var m=s("<h3>Por qué Rust</h3> <p>El ownership model evita fugas de memoria y me permite escribir bindings seguros para bibliotecas de criptografía post-cuántica.</p> <h3>Stack mínimo</h3> <ul><li><code>rustls</code> + <code>hpke</code> para encapsulado híbrido</li> <li><code>pqcrypto</code> para firmas Dilithium</li> <li>SQLite cifrado para almacenar claves rotativas</li></ul> <h3>Validación</h3> <p>Automatizo pruebas diferenciales con <code>cargo nextest</code> y utilizo <code>criterion</code> para perf. El resultado: latencia adicional &lt; 5ms en dispositivos ARM.</p>",1);function R(a,i){const o=n(i,["children","$$slots","$$events","$$legacy"]);d(a,l(()=>o,()=>e,{children:(t,u)=>{var r=m();p(10),c(t,r)},$$slots:{default:!0}}))}export{R as component};
